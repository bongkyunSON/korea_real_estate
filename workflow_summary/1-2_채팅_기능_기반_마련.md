# 1-2: 채팅 기능 기반 마련 (feat. 데이터 모델링 첫걸음)

이전 기록에 이어, 시니어 개발자로서 주니어인 당신과 함께 우리 서비스의 핵심 기능인 '채팅'의 뼈대를 만드는 과정을 기록합니다. 이번에는 눈에 보이는 기능이 아닌, 보이지 않는 곳에서 데이터를 담아낼 '그릇'을 설계하는 중요한 작업, '데이터 모델링'에 대해 함께 배웠습니다.

---

## 목표: AI와 사용자의 '대화 기록'을 담을 그릇 만들기

AI 챗봇이 아무리 똑똑하게 대답해도, 그 대화 내용이 사라져버린다면 아무 소용이 없겠죠. 우리는 사용자와 AI가 나눈 모든 대화를 안전하게 저장하고, 언제든 다시 꺼내볼 수 있도록 데이터베이스에 '대화방'과 '쪽지'라는 그릇을 만드는 것을 목표로 삼았습니다.

### Step 1: '대화방'과 '쪽지' 설계도 그리기 (`models/chat.py`)

- **우리가 한 일:** SQLAlchemy를 사용해서 데이터베이스에 어떤 테이블을 만들지 정의하는 '설계도'(모델 클래스)를 그렸습니다.
    - **`ChatRoom` 모델 ('대화방' 설계도):** 어떤 `User`('대화방 주인')가 만든 방인지 알 수 있도록 '주인님 명패'(`ForeignKey`)를 붙여주었습니다.
    - **`Message` 모델 ('쪽지' 설계도):** 이 쪽지가 어떤 `ChatRoom`('소속된 대화방')에 속한 것인지 '방 번호'(`ForeignKey`)를 붙여주었습니다.
- **주니어를 위한 핵심 개념:** 데이터 모델링은 집을 짓기 전에 설계도를 그리는 것과 같습니다. 각 방(테이블)이 어떤 정보를 담을지(컬럼), 그리고 방과 방이 어떻게 연결될지(관계) 미리 꼼꼼하게 설계해야 튼튼한 집(애플리케이션)을 지을 수 있습니다.

### Step 2: 설계도에 '양방향 통로' 만들기 (`models/user.py` 수정)

- **우리가 한 일:** '대화방' 설계도에서 '주인님'을 찾아갈 수 있는 길을 만든 것처럼, 반대로 '주인님'의 설계도(`User` 모델)에서도 자신이 가진 '대화방 목록'(`chat_rooms`)을 바로 찾아갈 수 있는 '양방향 통로'(`relationship`)를 만들어주었습니다.
- **주니어를 위한 핵심 개념:** `relationship`은 설계도 상의 가상 통로입니다. 이 통로 덕분에 우리는 복잡한 SQL 쿼리 없이, `my_user.chat_rooms`처럼 파이썬 코드만으로 매우 직관적으로 연결된 데이터를 가져올 수 있게 됩니다.

### Step 3: 주방의 '새로운 그릇'을 위한 '주문서'와 '영수증' 만들기 (`schemas/chat.py`)

- **우리가 한 일:** 새로운 '대화방'과 '쪽지'를 위한 API 입출력 양식을 Pydantic으로 정의했습니다.
    - **`ChatRoomCreate`**: 손님이 "새 대화방 만들어주세요" 라고 요청할 때 사용할 '주문서'.
    - **`MessageCreate`**: 손님이 "이 쪽지 좀 저 방에 넣어주세요" 라고 요청할 때 사용할 '쪽지 작성 양식'.
    - **`ChatRoom`, `Message`**: 요청이 처리된 후 손님에게 발행할 '영수증'.
- **주니어를 위한 핵심 개념:** 새로운 데이터 모델을 만들면, 그에 맞는 스키마도 함께 만들어주어야 합니다. 모델은 '주방 내부의 그릇', 스키마는 '손님에게 보여지는 주문서/영수증'으로, 역할이 명확하게 분리되어 있다는 점을 기억하는 것이 중요합니다.

### Step 4: '새로운 그릇'을 다룰 '전문 주방장' 배치하기 (`crud/chat.py`)

- **우리가 한 일:** 데이터베이스에 직접 접근해서 '대화방'과 '쪽지'를 만들고, 조회하는 역할을 전담할 '전문 주방장'(CRUD 함수)들을 `crud/chat.py`에 만들었습니다.
    - **`create_chat_room`**: 새 대화방 만들기 전문.
    - **`get_chat_rooms_by_user`**: 특정 사용자의 대화방 목록 조회 전문.
    - **`create_message_in_chatroom`**: 특정 대화방에 쪽지 넣기 전문.
- **주니어를 위한 핵심 개념:** 기능이 복잡해질수록 '역할 분리'는 더욱 중요해집니다. `crud`는 오직 데이터베이스 작업에만 집중함으로써, 코드 전체의 구조를 명확하고 깔끔하게 유지해줍니다.

### Step 5: '새로운 코너'를 위한 '웨이터'와 '안내판' 설치하기 (`routers/chat.py`, `main.py`)

- **우리가 한 일:**
    1.  손님의 채팅 관련 요청을 받을 '새로운 코너'(`chat` 라우터)를 만들고, 그곳에서 일할 '웨이터'(API 엔드포인트)들을 배치했습니다.
    2.  모든 '웨이터'에게는 `get_current_user`라는 '보안 요원'을 붙여주어, 반드시 '출입증'이 있는 손님의 주문만 받도록 했습니다.
    3.  레스토랑 정문(`main.py`)에 "채팅 코너는 저쪽입니다"(`prefix="/api/chat-rooms"`) 라는 '안내판'을 설치하여 손님들이 찾아올 수 있도록 했습니다.
- **주니어를 위한 핵심 개념:** 기능별로 라우터를 분리하는 것은, 레스토랑에 '한식 코너', '중식 코너'를 나누는 것과 같습니다. 이렇게 하면 관리가 편해지고, 나중에 새로운 '일식 코너'를 추가하기도 훨씬 쉬워집니다.

---

## 비동기 시대의 '지연 로딩' 함정 카드! 🐾

이번에도 우리는 만만치 않은 버그를 만났습니다. 바로 비동기(Async) 환경에서 SQLAlchemy를 사용할 때 자주 등장하는 `MissingGreenlet` 에러입니다.

- **사건 #1: `500 Internal Server Error (MissingGreenlet)`**
    - **증상:** "채팅방을 만들고 '영수증'을 출력하려는데, 내부에서 에러가 발생했습니다."
    - **원인:** '영수증'(`ChatRoom` 스키마)에는 '주문한 메뉴 목록'(`messages` 필드)이 포함되어 있었습니다. SQLAlchemy는 기본적으로 '게으른' 친구라서, 이 메뉴 목록을 진짜로 필요할 때(즉, 영수증을 출력하려는 순간) 다시 주방(DB)에 물어보려고 했습니다. (이를 **'지연 로딩'** 이라고 합니다.) 하지만 우리 레스토랑은 최첨단 '비동기' 시스템이라, 허락되지 않은 방식의 갑작스러운 주방 문의는 규칙 위반이었죠.
    - **해결:** "게으르게 나중에 물어보지 말고, 그냥 처음부터 메뉴 목록까지 싹 다 챙겨와!" 라고 SQLAlchemy에게 지시했습니다. `selectinload` 라는 옵션을 사용해 필요한 모든 정보를 **'즉시 로딩'** 하도록 하여 문제를 해결했습니다. 채팅방 생성(`create_chat_room`)과 목록 조회(`get_chat_rooms_by_user`) 두 곳에서 모두 이 함정을 피할 수 있었습니다.

이 경험을 통해 우리는 비동기 프로그래밍과 ORM의 상호작용에 대해 깊이 배울 수 있었습니다. 눈에 보이지 않는 데이터의 흐름을 이해하는 것, 이것이 바로 백엔드 개발의 묘미입니다!
